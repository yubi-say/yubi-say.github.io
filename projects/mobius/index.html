<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Möbius</title>
  <style>
    html, body { height: 100%; margin: 0; background: #f6f6f6; }
    canvas { display: block; width: 100vw; height: 100vh; }

    /* Editorial title — responsive */
    .title {
      position: fixed;
      left: clamp(14px, 2.2vw, 28px);
      top:  clamp(12px, 2.0vw, 26px);

      font-family: system-ui, -apple-system, Segoe UI, Arial;
      font-size: clamp(22px, 3.4vw, 52px);
      font-weight: 600;

      letter-spacing: clamp(0.18em, 0.55vw, 0.34em);
      text-transform: uppercase;

      color: rgba(0,0,0,0.62);
      user-select: none;
      pointer-events: none;
      mix-blend-mode: multiply;

      display: inline-flex;
      align-items: center;
      gap: clamp(10px, 1.2vw, 16px);
    }
    .title .dot {
      width:  clamp(8px, 1.0vw, 14px);
      height: clamp(8px, 1.0vw, 14px);
      border-radius: 999px;
      background: rgba(232,97,150,0.82);
      box-shadow: 0 0 0 1px rgba(0,0,0,0.08) inset;
      transform: translateY(-0.06em);
      opacity: 0.95;
      flex: 0 0 auto;
    }

    /* Minimal line-controls */
    .ui {
      position: fixed;
      left: clamp(14px, 2.2vw, 28px);
      bottom: clamp(14px, 2.2vw, 28px);
      padding: 10px 0;
      font-family: system-ui, -apple-system, Segoe UI, Arial;
      color: rgba(0,0,0,0.62);
      user-select: none;
      transition: opacity 240ms ease;
      opacity: 0.92;
    }
    .ui.hidden { opacity: 0; pointer-events: none; }

    .row {
      display: grid;
      grid-template-columns: 56px 210px 56px;
      gap: 10px;
      align-items: center;
      margin: 10px 0;
    }
    .label { font-size: 12px; letter-spacing: 0.2px; }
    .val { font-size: 12px; text-align: right; opacity: 0.82; }

    input[type="range"]{
      -webkit-appearance: none;
      appearance: none;
      width: 210px;
      height: 16px;
      background: transparent;
      margin: 0;
      padding: 0;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height: 2px;
      background: rgba(0,0,0,0.22);
      border-radius: 999px;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance: none;
      appearance: none;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: rgba(0,0,0,0.55);
      margin-top: -4px;
      border: 0;
    }
    input[type="range"]::-moz-range-track{
      height: 2px;
      background: rgba(0,0,0,0.22);
      border: 0;
      border-radius: 999px;
    }
    input[type="range"]::-moz-range-thumb{
      width: 10px; height: 10px;
      border-radius: 50%;
      background: rgba(0,0,0,0.55);
      border: 0;
    }

    .buttons { display: flex; gap: 14px; margin-top: 8px; }
    button{
      appearance: none;
      border: 0;
      background: transparent;
      padding: 6px 0;
      font-size: 12px;
      letter-spacing: 0.2px;
      color: rgba(0,0,0,0.62);
      cursor: pointer;
      border-bottom: 1px solid rgba(0,0,0,0.18);
    }
    button:hover { color: rgba(0,0,0,0.78); border-bottom-color: rgba(0,0,0,0.30); }

    @media (max-width: 420px) {
      .row { grid-template-columns: 56px 160px 56px; }
      input[type="range"]{ width: 160px; }
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="title"><span class="dot"></span>Möbius</div>

<div class="ui" id="ui">
  <div class="row">
    <div class="label">Width</div>
    <input id="width" type="range" min="0.08" max="0.42" step="0.01" value="0.32" />
    <div class="val" id="widthVal"></div>
  </div>
  <div class="row">
    <div class="label">Twist</div>
    <input id="twist" type="range" min="0" max="1" step="0.01" value="1.00" />
    <div class="val" id="twistVal"></div>
  </div>
  <div class="row">
    <div class="label">Speed</div>
    <input id="speed" type="range" min="0" max="1.8" step="0.02" value="0.90" />
    <div class="val" id="speedVal"></div>
  </div>
  <div class="row">
    <div class="label">Ball</div>
    <input id="ball" type="range" min="0.60" max="1.60" step="0.02" value="1.00" />
    <div class="val" id="ballVal"></div>
  </div>

  <div class="buttons">
    <button id="pauseBtn">Pause</button>
    <button id="resetBtn">Reset</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const ui = document.getElementById("ui");
  const uiWidth = document.getElementById("width");
  const uiTwist = document.getElementById("twist");
  const uiSpeed = document.getElementById("speed");
  const uiBall  = document.getElementById("ball");

  const widthVal = document.getElementById("widthVal");
  const twistVal = document.getElementById("twistVal");
  const speedVal = document.getElementById("speedVal");
  const ballVal  = document.getElementById("ballVal");

  const pauseBtn = document.getElementById("pauseBtn");
  const resetBtn = document.getElementById("resetBtn");

  let paused = false;
  let tTime = 0;

  const bg = "#f6f6f6";

  const R = 1.35;
  const perspective = 2.55;
  const pitch = 0.55;

  const lightDir = normalize3([0.35, -0.25, 1.0]);

  const baseRGB = [70, 73, 78];
  const highlightRGB = [232, 97, 150];
  const edgeAlpha = 0.08;

  const SEGMENTS = 280;
  const dtN = 0.004;
  const dvN = 0.02;

  const ballTrackOffsetV = 0.0;

  const SNAP_POINTS = [0, 0.5, 1];
  const SNAP_RADIUS = 0.08;
  const SNAP_STRENGTH = 0.85;

  // UI auto-hide
  let uiHideTimer = null;
  function showUI() {
    ui.classList.remove("hidden");
    if (uiHideTimer) clearTimeout(uiHideTimer);
    uiHideTimer = setTimeout(() => ui.classList.add("hidden"), 1600);
  }
  window.addEventListener("mousemove", showUI, { passive:true });
  window.addEventListener("touchstart", showUI, { passive:true });
  showUI();

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = "100vw";
    canvas.style.height = "100vh";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function mix(a,b,t){ return a + (b-a)*t; }

  function normalize3(v){
    const m = Math.hypot(v[0], v[1], v[2]) || 1;
    return [v[0]/m, v[1]/m, v[2]/m];
  }
  function dot3(a,b){ return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
  function sub3(a,b){ return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
  function cross3(a,b){
    return [
      a[1]*b[2]-a[2]*b[1],
      a[2]*b[0]-a[0]*b[2],
      a[0]*b[1]-a[1]*b[0]
    ];
  }

  function rotY(p, a){
    const c = Math.cos(a), s = Math.sin(a);
    return [ p[0]*c + p[2]*s, p[1], -p[0]*s + p[2]*c ];
  }
  function rotX(p, a){
    const c = Math.cos(a), s = Math.sin(a);
    return [ p[0], p[1]*c - p[2]*s, p[1]*s + p[2]*c ];
  }

  function ribbonPoint(t, v, twistTurns){
    const u = t;
    const w = twistTurns * u;
    const cw = Math.cos(w), sw = Math.sin(w);

    const x = (R + v * cw) * Math.cos(u);
    const y = (R + v * cw) * Math.sin(u);
    const z = v * sw;
    return [x, y, z];
  }

  function project(p3, yaw, scale, cx, cy){
    let p = rotY(p3, yaw);
    p = rotX(p, pitch);
    const z = p[2];
    const k = perspective / (perspective - z);
    return { x: cx + p[0] * k * scale, y: cy + p[1] * k * scale, z, k };
  }

  function normalAt(t, twistTurns, yaw){
    const pt1 = ribbonPoint(t + dtN, 0, twistTurns);
    const pt2 = ribbonPoint(t - dtN, 0, twistTurns);
    const pv1 = ribbonPoint(t, dvN, twistTurns);
    const pv2 = ribbonPoint(t, -dvN, twistTurns);

    const tang = sub3(pt1, pt2);
    const bin  = sub3(pv1, pv2);
    let n = cross3(tang, bin);
    n = normalize3(n);

    n = rotY(n, yaw);
    n = rotX(n, pitch);
    return normalize3(n);
  }

  function shade(base, nDotL){
    const lit = clamp((nDotL + 0.15) / 1.15, 0, 1);
    const tone = mix(0.22, 0.98, lit);

    const r = mix(base[0], highlightRGB[0], 0.20) * tone;
    const g = mix(base[1], highlightRGB[1], 0.12) * tone;
    const b = mix(base[2], highlightRGB[2], 0.22) * tone;

    return { r, g, b };
  }

  function rgba(r,g,b,a){ return `rgba(${r|0},${g|0},${b|0},${a})`; }

  function snapTwist(x){
    let best = 0, bestD = 1e9;
    for (const p of SNAP_POINTS){
      const d = Math.abs(x - p);
      if (d < bestD) { bestD = d; best = p; }
    }
    if (bestD > SNAP_RADIUS) return x;

    const t = 1 - clamp(bestD / SNAP_RADIUS, 0, 1);
    const strength = SNAP_STRENGTH * (t*t*(3-2*t));
    return mix(x, best, strength);
  }

  function defaultBallRadiusPx(W, H){
    const s = Math.min(W, H);
    // ✅ proportional default: clamp(8px, 1.2% of short side, 16px)
    return clamp(s * 0.012, 8, 16);
  }

  function updateUI(){
    widthVal.textContent = (+uiWidth.value).toFixed(2);
    twistVal.textContent = (+uiTwist.value).toFixed(2);
    speedVal.textContent = (+uiSpeed.value).toFixed(2);

    // display ball size in px (computed from viewport)
    const W = window.innerWidth, H = window.innerHeight;
    const basePx = defaultBallRadiusPx(W, H);
    const px = basePx * (+uiBall.value);
    ballVal.textContent = `${px.toFixed(0)}px`;

    pauseBtn.textContent = paused ? "Play" : "Pause";
  }

  [uiWidth, uiTwist, uiSpeed, uiBall].forEach(el => {
    el.addEventListener("input", () => { updateUI(); showUI(); });
  });

  pauseBtn.addEventListener("click", () => { paused = !paused; updateUI(); showUI(); });
  resetBtn.addEventListener("click", () => { tTime = 0; showUI(); });

  window.addEventListener("resize", updateUI);
  updateUI();

  function draw() {
    const W = window.innerWidth;
    const H = window.innerHeight;

    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, W, H);

    const scale = Math.min(W, H) * 0.23;
    const cx = W * 0.52;
    const cy = H * 0.50;

    const ribbonHalfWidth = +uiWidth.value;
    const twistTurns = snapTwist(+uiTwist.value);
    const speed = +uiSpeed.value;

    // ball radius responsive default * multiplier
    const ballRadiusPx = defaultBallRadiusPx(W, H) * (+uiBall.value);

    const yaw = tTime * (0.60 * speed);

    const items = [];

    for (let i = 0; i < SEGMENTS; i++) {
      const t0 = (i / SEGMENTS) * Math.PI * 2;
      const t1 = ((i + 1) / SEGMENTS) * Math.PI * 2;

      const isLast = (i === SEGMENTS - 1);
      const vFlip = (Math.abs(twistTurns - 0.5) < 1e-6) && isLast ? -1 : 1;

      const p00 = ribbonPoint(t0, -ribbonHalfWidth, twistTurns);
      const p01 = ribbonPoint(t0,  ribbonHalfWidth, twistTurns);

      const p10 = ribbonPoint(t1, -ribbonHalfWidth * vFlip, twistTurns);
      const p11 = ribbonPoint(t1,  ribbonHalfWidth * vFlip, twistTurns);

      const a = project(p00, yaw, scale, cx, cy);
      const b = project(p01, yaw, scale, cx, cy);
      const c = project(p11, yaw, scale, cx, cy);
      const d = project(p10, yaw, scale, cx, cy);

      const zAvg = (a.z + b.z + c.z + d.z) / 4;
      const tMid = (t0 + t1) * 0.5;
      const n = normalAt(tMid, twistTurns, yaw);
      const ndotl = dot3(n, lightDir);

      items.push({ kind: "quad", z: zAvg, ndotl, a,b,c,d });
    }

    // Ball on centerline
    const tBall = (tTime * (0.95 * speed)) % (Math.PI * 2);
    const pBall3 = ribbonPoint(tBall, ballTrackOffsetV, twistTurns);
    const pBall = project(pBall3, yaw, scale, cx, cy);
    const nBall = normalAt(tBall, twistTurns, yaw);
    const ndotlBall = dot3(nBall, lightDir);

    items.push({ kind: "ball", z: pBall.z + 0.001, ndotl: ndotlBall, x: pBall.x, y: pBall.y });

    items.sort((i1, i2) => i1.z - i2.z);

    for (const it of items) {
      if (it.kind === "quad") {
        const { r, g, b } = shade(baseRGB, it.ndotl);

        ctx.beginPath();
        ctx.moveTo(it.a.x, it.a.y);
        ctx.lineTo(it.b.x, it.b.y);
        ctx.lineTo(it.c.x, it.c.y);
        ctx.lineTo(it.d.x, it.d.y);
        ctx.closePath();

        ctx.fillStyle = rgba(r, g, b, 0.92);
        ctx.fill();

        ctx.strokeStyle = `rgba(0,0,0,${edgeAlpha})`;
        ctx.lineWidth = 1;
        ctx.stroke();
      } else {
        const { r, g, b } = shade([88, 92, 98], it.ndotl);

        const rr = ballRadiusPx;
        const gx = it.x - rr * 0.32;
        const gy = it.y - rr * 0.38;

        const grad = ctx.createRadialGradient(gx, gy, rr*0.18, it.x, it.y, rr*1.15);
        grad.addColorStop(0, rgba(255, 255, 255, 0.95));
        grad.addColorStop(0.22, rgba(r, g, b, 0.96));
        grad.addColorStop(1, rgba(22, 24, 28, 0.55));

        ctx.beginPath();
        ctx.arc(it.x, it.y, rr, 0, Math.PI*2);
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.strokeStyle = "rgba(0,0,0,0.18)";
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    const grd = ctx.createRadialGradient(cx, cy, Math.min(W,H)*0.10, cx, cy, Math.min(W,H)*0.60);
    grd.addColorStop(0, "rgba(0,0,0,0)");
    grd.addColorStop(1, "rgba(0,0,0,0.06)");
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
  }

  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    if (!paused) tTime += dt;
    draw();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>

