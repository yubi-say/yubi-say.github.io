<!doctype html>
<html lang="es">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Golden Ratio Unfold (SVG + FLIP)</title>
	<style>
		html,
		body {
			height: 100%;
			margin: 0;
			background: #f6f6f6;
		}

		#stage {
			width: 100vw;
			height: 100vh;
			position: relative;
			overflow: hidden;
		}

		svg {
			width: 100%;
			height: 100%;
			display: block;
		}

		#titleOverlay {
			position: absolute;
			inset: 0;
			display: grid;
			place-items: center;
			pointer-events: none;
		}

		#titleOverlay .title {
			font-family: system-ui, -apple-system, Segoe UI, Arial;
			font-weight: 600;
			letter-spacing: 0.5px;
			color: rgba(0, 0, 0, 0.72);
			font-size: clamp(22px, 4.2vw, 56px);
			transform: scale(1);
			opacity: 0;
			filter: blur(0px);
		}

		.sq rect {
			fill: rgba(0, 0, 0, 0.035);
			stroke: rgba(0, 0, 0, 0.55);
			stroke-width: 1.6;
			vector-effect: non-scaling-stroke;
			shape-rendering: geometricPrecision;
		}

		.sq text {
			fill: rgba(0, 0, 0, 0.42);
			font-family: system-ui, -apple-system, Segoe UI, Arial;
			font-weight: 500;
			text-anchor: middle;
			dominant-baseline: central;
			letter-spacing: 0.2px;
			user-select: none;
		}

		.arc {
			fill: none;
			stroke: rgba(232, 97, 150, 0.92);
			stroke-width: 2.6;
			vector-effect: non-scaling-stroke;
			stroke-linecap: round;
			stroke-linejoin: round;
		}

		.flip {
			transform-box: fill-box;
			transform-origin: center;
			will-change: transform;
		}
	</style>
</head>

<body>
	<div id="stage">
		<div id="titleOverlay">
			<div class="title">Golden Ratio Unfold</div>
		</div>

		<svg id="svg" viewBox="-2 -2 10 10" preserveAspectRatio="xMidYMid meet">
			<defs>
				<filter id="glow" x="-70%" y="-70%" width="240%" height="240%">
					<feDropShadow dx="0" dy="0" stdDeviation="3.8" flood-color="rgba(255, 214, 80, 0.98)" />
					<feDropShadow dx="0" dy="0" stdDeviation="10.0" flood-color="rgba(255, 214, 80, 0.58)" />
				</filter>
			</defs>
			<g id="world"></g>
		</svg>
	</div>

	<script>
		(() => {
  const svg = document.getElementById("svg");
  const world = document.getElementById("world");

  // ====== Config ======
  const COUNT = 11;                 // 1..89
  const PAD = 3.0;

  // Forward timing
  const MOVE_MS = 560;
  const ARC_MS  = 520;
  const STEP_PAUSE_MS = 260;

  // ✅ New: square outline draw (fast)
  const RECT_DRAW_MS = 220;

  // End timing
  const END_HOLD_MS = 850;
  const END_BOUNCE_MS = 620;

  // Backward timing
  const BACK_MOVE_MS = 420;
  const BACK_ARC_MS  = 520;
  const BACK_STEP_PAUSE_MS = 220;
  const BACK_SQUARE_FADE_MS = 320;

  const EASE = "cubic-bezier(.2,.8,.2,1)";
  const EASE_SOFT = "cubic-bezier(.16,1,.3,1)";
  const EASE_FLASH = "cubic-bezier(.08,1,.22,1)";

  const NUMBER_SCALE = 0.40;
  const NUMBER_DY_EM = "0.06em";

  const ns = "http://www.w3.org/2000/svg";
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  function makeEl(tag, attrs = {}) {
    const el = document.createElementNS(ns, tag);
    for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));
    return el;
  }

  function safeAnimate(el, keyframes, options) {
    try {
      const anim = el.animate(keyframes, options);
      return anim.finished.catch(() => {});
    } catch {
      return Promise.resolve();
    }
  }

  function currentViewBox() {
    const [x,y,w,h] = svg.getAttribute("viewBox").split(/\s+/).map(Number);
    return {x,y,w,h};
  }

  function animateViewBox(from, to, ms) {
    const t0 = performance.now();
    return new Promise(resolve => {
      function tick(now) {
        const p = clamp((now - t0) / ms, 0, 1);
        const e = p*p*(3-2*p);
        const v = {
          x: from.x + (to.x - from.x) * e,
          y: from.y + (to.y - from.y) * e,
          w: from.w + (to.w - from.w) * e,
          h: from.h + (to.h - from.h) * e,
        };
        svg.setAttribute("viewBox", `${v.x} ${v.y} ${v.w} ${v.h}`);
        if (p < 1) requestAnimationFrame(tick);
        else resolve();
      }
      requestAnimationFrame(tick);
    });
  }

  function flipAnimate(el, firstRect, lastRect, ms) {
    const dx = firstRect.left - lastRect.left;
    const dy = firstRect.top - lastRect.top;
    const sx = firstRect.width / Math.max(1, lastRect.width);
    const sy = firstRect.height / Math.max(1, lastRect.height);

    el.style.transform = `translate(${dx}px, ${dy}px) scale(${sx}, ${sy})`;

    el.animate(
      [
        { transform: `translate(${dx}px, ${dy}px) scale(${sx}, ${sy})` },
        { transform: "translate(0px, 0px) scale(1, 1)" }
      ],
      { duration: ms, easing: EASE, fill: "forwards" }
    );

    setTimeout(() => { el.style.transform = ""; }, ms + 30);
  }

  // ====== Spiral arcs ======
  function arcPathForSquare(q) {
    const {x,y,s,dirPlaced} = q;
    if (dirPlaced == null) return null;

    let cx, cy, a0, a1;
    if (dirPlaced === 2) {        // LEFT -> center bottom-right
      cx = x + s; cy = y + s; a0 = Math.PI; a1 = 1.5*Math.PI;
    } else if (dirPlaced === 3) { // DOWN -> center top-right
      cx = x + s; cy = y; a0 = 0.5*Math.PI; a1 = Math.PI;
    } else if (dirPlaced === 0) { // RIGHT -> center top-left
      cx = x; cy = y; a0 = 0; a1 = 0.5*Math.PI;
    } else {                      // UP -> center bottom-left
      cx = x; cy = y + s; a0 = -0.5*Math.PI; a1 = 0;
    }

    const x0 = cx + s * Math.cos(a0);
    const y0 = cy + s * Math.sin(a0);
    const x1 = cx + s * Math.cos(a1);
    const y1 = cy + s * Math.sin(a1);

    return `M ${x0} ${y0} A ${s} ${s} 0 0 1 ${x1} ${y1}`;
  }

  function fitViewToBounds(bounds) {
    const w = bounds.maxX - bounds.minX;
    const h = bounds.maxY - bounds.minY;
    const x = bounds.minX - PAD;
    const y = bounds.minY - PAD;
    return { x, y, w: w + PAD*2, h: h + PAD*2 };
  }

  // ====== Fibonacci ======
  const fib = [1,1];
  while (fib.length < COUNT) fib.push(fib[fib.length-1] + fib[fib.length-2]);

  // ====== Model ======
  const model = [];
  model.push({ x: 0, y: 0,  s: 1, n: 1, dirPlaced: 0 });
  model.push({ x: 0, y: -1, s: 1, n: 1, dirPlaced: 1 });

  let minX=0, minY=-1, maxX=1, maxY=1;
  let dir = 2;

  for (let i=2; i<fib.length; i++) {
    const s = fib[i];
    let x,y;
    if (dir===0){ x=maxX; y=minY; maxX+=s; }
    else if (dir===1){ x=minX; y=minY-s; minY-=s; }
    else if (dir===2){ x=minX-s; y=minY; minX-=s; }
    else { x=minX; y=maxY; maxY+=s; }

    model.push({ x,y,s,n:s,dirPlaced:dir });
    dir = (dir+1)%4;
  }

  function boundsUpTo(k) {
    let b = {minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity};
    for (let i=0; i<=k; i++) {
      const q = model[i];
      b.minX = Math.min(b.minX, q.x);
      b.minY = Math.min(b.minY, q.y);
      b.maxX = Math.max(b.maxX, q.x + q.s);
      b.maxY = Math.max(b.maxY, q.y + q.s);
    }
    return b;
  }

  // ====== Nodes ======
  const nodesByIndex = new Map();

  function ensureNode(i) {
    if (nodesByIndex.has(i)) return nodesByIndex.get(i);

    const g = makeEl("g", { class: "sq flip", "data-i": i });
    const rect = makeEl("rect", { x:0, y:0, width:1, height:1 });
    const text = makeEl("text", { x:0, y:0, dy: NUMBER_DY_EM });
    const arc  = makeEl("path", { class: "arc", d: "" });

    g.appendChild(rect);
    g.appendChild(text);
    world.appendChild(g);
    world.appendChild(arc);

    nodesByIndex.set(i, { g, rect, text, arc });
    return nodesByIndex.get(i);
  }

  function updateNode(i, q) {
    const node = ensureNode(i);
    const { rect, text, arc } = node;

    rect.setAttribute("x", q.x);
    rect.setAttribute("y", q.y);
    rect.setAttribute("width",  q.s);
    rect.setAttribute("height", q.s);

    const fontModel = clamp(q.s * NUMBER_SCALE, q.s * 0.28, q.s * 0.50);
    text.setAttribute("x", q.x + q.s/2);
    text.setAttribute("y", q.y + q.s/2);
    text.setAttribute("font-size", fontModel);
    text.textContent = String(q.n);

    const d = arcPathForSquare(q);
    if (d) { arc.setAttribute("d", d); arc.style.opacity = "1"; }
    else { arc.setAttribute("d",""); arc.style.opacity = "0"; }
  }

  // ====== Effects ======

  // ✅ Draw square outline quickly (stroke-dash)
  async function drawRectOutline(i) {
    const node = nodesByIndex.get(i);
    if (!node) return;
    const { rect } = node;

    // perimeter in "model units"
    const w = Number(rect.getAttribute("width")) || 0;
    const h = Number(rect.getAttribute("height")) || 0;
    const p = 2 * (w + h);
    if (!isFinite(p) || p <= 0) return;

    // Start with only stroke drawn, keep fill subtle
    rect.style.strokeDasharray = String(p);
    rect.style.strokeDashoffset = String(p);

    await safeAnimate(rect,
      [{ strokeDashoffset: p }, { strokeDashoffset: 0 }],
      { duration: RECT_DRAW_MS, easing: EASE, fill: "forwards" }
    );

    // Clear dash so the border stays normal
    rect.style.strokeDasharray = "";
    rect.style.strokeDashoffset = "";
  }

  function flashSquareOnlyNew(i) {
    const node = nodesByIndex.get(i);
    if (!node) return;
    const { rect } = node;

    rect.setAttribute("filter", "url(#glow)");
    rect.animate(
      [
        { fill: "rgba(255, 235, 59, 0.92)" },
        { fill: "rgba(255, 235, 59, 0.20)" },
        { fill: "rgba(0,0,0,0.035)" }
      ],
      { duration: 560, easing: EASE_FLASH, fill: "forwards" }
    );
    setTimeout(() => rect.removeAttribute("filter"), 610);
  }

  function prepareArcForDraw(arc) {
    const len = arc.getTotalLength();
    arc.style.strokeDasharray = String(len);
    arc.style.strokeDashoffset = String(len);
    return len;
  }

  function clearArcDash(arc) {
    arc.style.strokeDasharray = "";
    arc.style.strokeDashoffset = "";
  }

  function animateArcForward(i) {
    const node = nodesByIndex.get(i);
    if (!node) return;
    const { arc } = node;
    const d = arc.getAttribute("d");
    if (!d) return;

    arc.style.opacity = "1";
    let len = 0;
    try { len = prepareArcForDraw(arc); } catch { return; }

    const anim = arc.animate(
      [{ strokeDashoffset: len }, { strokeDashoffset: 0 }],
      { duration: ARC_MS, easing: EASE, fill: "forwards" }
    );
    anim.onfinish = () => clearArcDash(arc);
  }

  async function animateArcBackward(i) {
    const node = nodesByIndex.get(i);
    if (!node) return;
    const { arc } = node;

    const d = arc.getAttribute("d");
    if (!d) return;

    let len = 0;
    try { len = arc.getTotalLength(); } catch { return; }

    arc.style.strokeDasharray = String(len);
    arc.style.strokeDashoffset = "0";
    arc.style.opacity = "1";

    await safeAnimate(arc, [{ strokeDashoffset: 0 }, { strokeDashoffset: len }], {
      duration: BACK_ARC_MS, easing: EASE, fill: "forwards"
    });

    await safeAnimate(arc, [{opacity:1},{opacity:0}], {duration: 160, easing: EASE, fill:"forwards"});
  }

  async function bounceEnd() {
    await safeAnimate(world,
      [{ transform: "scale(1)" }, { transform: "scale(1.02)" }, { transform: "scale(1)" }],
      { duration: END_BOUNCE_MS, easing: EASE_SOFT, fill: "forwards" }
    );
  }

  async function clearAll(ms = 220) {
    if (world.childNodes.length > 0 && ms > 0) {
      await safeAnimate(world, [{opacity:1},{opacity:0}], {duration: ms, easing: EASE, fill:"forwards"});
    }
    world.innerHTML = "";
    nodesByIndex.clear();
    world.style.opacity = "1";
  }

  // ====== Forward / backward ======
  async function runForward() {
    const vb0 = fitViewToBounds(boundsUpTo(0));
    svg.setAttribute("viewBox", `${vb0.x} ${vb0.y} ${vb0.w} ${vb0.h}`);

    for (let i=0; i<model.length; i++) {
      const firstRects = new Map();
      for (const [idx, node] of nodesByIndex) firstRects.set(idx, node.g.getBoundingClientRect());

      for (let k=0; k<=i; k++) updateNode(k, model[k]);

      const vbFrom = currentViewBox();
      const vbTo = fitViewToBounds(boundsUpTo(i));
      const cameraPromise = animateViewBox(vbFrom, vbTo, MOVE_MS);

      await new Promise(r => requestAnimationFrame(r));

      for (let k=0; k<=i; k++) {
        const node = nodesByIndex.get(k);
        const last = node.g.getBoundingClientRect();
        const first = firstRects.get(k);
        if (first) flipAnimate(node.g, first, last, MOVE_MS);
      }

      const newNode = nodesByIndex.get(i);
      if (newNode) newNode.g.animate([{opacity:0}, {opacity:1}], {duration: 260, easing: EASE, fill:"forwards"});

      // ✅ New square: outline draw -> flash -> arc draw
      await drawRectOutline(i);
      flashSquareOnlyNew(i);
      setTimeout(() => animateArcForward(i), 160);

      await cameraPromise;
      await sleep(STEP_PAUSE_MS);
    }
  }

  async function runBackward() {
    for (let i=model.length-1; i>=0; i--) {
      const node = nodesByIndex.get(i);
      if (!node) continue;

      await animateArcBackward(i);

      await safeAnimate(node.g, [{opacity:1},{opacity:0}], {
        duration: BACK_SQUARE_FADE_MS, easing: EASE, fill:"forwards"
      });

      node.arc.remove();
      node.g.remove();
      nodesByIndex.delete(i);

      const k = i-1;
      if (k >= 0) {
        const vbFrom = currentViewBox();
        const vbTo = fitViewToBounds(boundsUpTo(k));
        await animateViewBox(vbFrom, vbTo, BACK_MOVE_MS);
      }
      await sleep(BACK_STEP_PAUSE_MS);
    }
  }

  // ====== Title intro ======
  async function playTitleIntro() {
    const overlay = document.getElementById("titleOverlay");
    const titleEl = overlay.querySelector(".title");

    await safeAnimate(titleEl,
      [{ opacity: 0, transform: "scale(0.985)", filter: "blur(2px)" },
       { opacity: 1, transform: "scale(1)",     filter: "blur(0px)" }],
      { duration: 650, easing: EASE_SOFT, fill: "forwards" }
    );

    await sleep(700);

    await safeAnimate(titleEl,
      [{ opacity: 1, transform: "scale(1)",    filter: "blur(0px)" },
       { opacity: 0, transform: "scale(1.03)", filter: "blur(4px)" }],
      { duration: 520, easing: EASE, fill: "forwards" }
    );

    overlay.style.display = "none";
  }

  // ====== Loop (robust) ======
  async function mainLoop() {
    await playTitleIntro();

    while (true) {
      try {
        world.style.opacity = "1";
        await clearAll(0);

        await runForward();

        await sleep(END_HOLD_MS);
        await bounceEnd();
        await sleep(350);

        await runBackward();
        await sleep(220);

        // Reset camera explicitly before restarting
        const vb0 = fitViewToBounds(boundsUpTo(0));
        svg.setAttribute("viewBox", `${vb0.x} ${vb0.y} ${vb0.w} ${vb0.h}`);

        await clearAll(140);
        await sleep(180);
      } catch {
        await clearAll(120);
        await sleep(240);
      }
    }
  }

  mainLoop();
})();
	</script>
</body>

</html>
