<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Solar System — Clean 3D</title>
	<style>
		:root {
			--ink: rgba(255, 255, 255, .92);
			--muted: rgba(255, 255, 255, .60);
		}

		* {
			box-sizing: border-box
		}

		html,
		body {
			height: 100%
		}

		body {
			margin: 0;
			overflow: hidden;
			color: var(--ink);
			font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
			background:
				radial-gradient(1200px 700px at 1000% 32%,
					rgba(10, 14, 38, 0.55) 0%,
					rgba(5, 6, 14, 0.90) 48%,
					rgba(2, 2, 6, 1) 100%);
		}

		#stars {
			position: fixed;
			inset: 0;
			width: 100%;
			height: 100%;
			z-index: 0;
			display: block;
			filter: contrast(112%) saturate(115%);
		}

		#webgl {
			position: fixed;
			inset: 0;
			width: 100%;
			height: 100%;
			z-index: 2;
			display: block;
			cursor: default;
		}

		.title {
			position: fixed;
			top: 18px;
			left: 50%;
			transform: translateX(-50%);
			z-index: 6;
			font-size: 20px;
			letter-spacing: 1.2px;
			text-transform: uppercase;
			color: rgba(255, 255, 255, .90);
			user-select: none;
			pointer-events: none;
			text-shadow: 0 10px 40px rgba(0, 0, 0, .55);
		}

		.controls {
			position: fixed;
			left: 50%;
			bottom: 18px;
			transform: translateX(-50%);
			z-index: 6;
			display: flex;
			align-items: center;
			gap: 12px;
			padding: 6px 10px;

			background: rgba(0, 0, 0, .12);
			backdrop-filter: blur(10px);

			color: var(--muted);
			font-size: 12px;
			user-select: none;
		}

		.controls .group {
			display: flex;
			align-items: center;
			gap: 8px;
			white-space: nowrap;
		}

		.controls label {
			letter-spacing: .35px;
			opacity: .88;
		}

		.controls input[type="range"] {
			width: 130px;
			accent-color: rgba(255, 255, 255, .72);
			height: 0px;
		}

		.controls input[type="range"]::-webkit-slider-runnable-track {
			height: 2px;
			border-radius: 999px;
			background: rgba(255, 255, 255, .22);
		}

		.controls input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none;
			width: 10px;
			height: 10px;
			margin-top: -4px;
			border-radius: 999px;
			background: rgba(255, 255, 255, .85);
			border: 1px solid rgba(0, 0, 0, .25);
		}

		.controls input[type="range"]::-moz-range-track {
			height: 2px;
			border-radius: 999px;
			background: rgba(255, 255, 255, .22);
		}

		.controls input[type="range"]::-moz-range-thumb {
			width: 10px;
			height: 10px;
			border-radius: 999px;
			background: rgba(255, 255, 255, .85);
			border: 1px solid rgba(0, 0, 0, .25);
		}

		.val {
			width: 40px;
			font-variant-numeric: tabular-nums;
			color: rgba(255, 255, 255, .74);
		}

		.tip {
			position: fixed;
			z-index: 7;
			left: 0;
			top: 0;
			transform: translate(-50%, -140%);
			padding: 7px 10px;
			border: 1px solid rgba(255, 255, 255, .14);
			background: rgba(0, 0, 0, .30);
			backdrop-filter: blur(10px);
			border-radius: 10px;
			font-size: 12px;
			letter-spacing: .4px;
			color: rgba(255, 255, 255, .86);
			pointer-events: none;
			opacity: 0;
			transition: opacity .12s ease;
			user-select: none;
			white-space: nowrap;
		}

		.tip.on {
			opacity: 1;
		}

		@media (max-width: 720px) {
			.controls {
				width: calc(100% - 24px);
				justify-content: space-between;
				gap: 10px;
			}

			.controls input[type="range"] {
				width: 115px;
			}

			.title {
				font-size: 18px;
			}
		}

		@media (max-width: 520px) {
			.controls input[type="range"] {
				width: 92px;
			}
		}
	</style>
</head>

<body>
	<canvas id="stars"></canvas>
	<canvas id="webgl"></canvas>

	<div class="title">Solar System</div>

	<div class="controls" aria-label="Controls">
		<div class="group">
			<label for="speed">Speed</label>
			<input id="speed" type="range" min="0.15" max="2.25" step="0.05" value="0.50">
			<div class="val" id="speedVal">0.50</div>
		</div>

		<div class="group">
			<label for="tilt">Tilt</label>
			<input id="tilt" type="range" min="10" max="78" step="1" value="10">
			<div class="val" id="tiltVal">10°</div>
		</div>

		<div class="group">
			<label for="zoom">Zoom</label>
			<input id="zoom" type="range" min="0.78" max="1.55" step="0.01" value="1">
			<div class="val" id="zoomVal">1.00</div>
		</div>
	</div>

	<div class="tip" id="tip"></div>

	<script type="module">
		import * as THREE from "https://unpkg.com/three@0.158.0/build/three.module.js";

		// ---------- Stars ----------
		const starsCanvas = document.getElementById("stars");
		const sctx = starsCanvas.getContext("2d", { alpha: true });
		let SW = 0, SH = 0, stars = [];

		function resizeStars() {
			SW = starsCanvas.width = Math.floor(innerWidth * devicePixelRatio);
			SH = starsCanvas.height = Math.floor(innerHeight * devicePixelRatio);
			starsCanvas.style.width = "100%";
			starsCanvas.style.height = "100%";

			const count = Math.floor((innerWidth * innerHeight) / 4200);
			stars = new Array(count).fill(0).map(() => ({
				x: Math.random() * SW,
				y: Math.random() * SH,
				r: (Math.random() * 1.55 + 0.18) * devicePixelRatio,
				a: Math.random() * 0.80 + 0.08,
			}));
			drawStars();
		}

		function drawStars() {
			sctx.clearRect(0, 0, SW, SH);

			const g = sctx.createRadialGradient(
				SW * 0.5, SH * 0.32, 0,
				SW * 0.5, SH * 0.32, Math.max(SW, SH) * 0.75
			);
			g.addColorStop(0, "rgba(90,120,255,0.08)");
			g.addColorStop(0.35, "rgba(60,80,200,0.03)");
			g.addColorStop(1, "rgba(0,0,0,0)");
			sctx.fillStyle = g;
			sctx.fillRect(0, 0, SW, SH);

			for (const st of stars) {
				sctx.globalAlpha = st.a;
				sctx.beginPath();
				sctx.arc(st.x, st.y, st.r, 0, Math.PI * 2);
				sctx.fillStyle = "white";
				sctx.fill();
			}
			sctx.globalAlpha = 1;
		}

		// ---------- WebGL ----------
		const canvas = document.getElementById("webgl");
		const renderer = new THREE.WebGLRenderer({
			canvas, antialias: true, alpha: true, powerPreference: "high-performance"
		});
		renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
		renderer.setSize(innerWidth, innerHeight, false);

		renderer.outputColorSpace = THREE.SRGBColorSpace;
		renderer.toneMapping = THREE.ACESFilmicToneMapping;
		renderer.toneMappingExposure = 1.12;

		const scene = new THREE.Scene();
		scene.fog = null;

		const camera = new THREE.PerspectiveCamera(44, innerWidth / innerHeight, 0.1, 25000);
		scene.add(camera);

		// ---------- System groups ----------
		const system = new THREE.Group();
		scene.add(system);

		const orbitPlane = new THREE.Group();
		system.add(orbitPlane);

		// ---------- Procedural textures ----------
		function makePlanetTexture({ base1, base2, band = false, speck = false, clouds = false, continents = false, polarCaps = false }) {
			const c = document.createElement("canvas");
			c.width = 512; c.height = 256;
			const ctx = c.getContext("2d");

			// base gradient (latitude-only; avoids "rotating shadow" look)
			const grd = ctx.createLinearGradient(0, 0, 0, 256);
			grd.addColorStop(0, base1);
			grd.addColorStop(1, base2);
			ctx.fillStyle = grd;
			ctx.fillRect(0, 0, 512, 256);

			const lat = ctx.createLinearGradient(0, 0, 0, 256);
			lat.addColorStop(0, "rgba(0,0,0,0.16)");
			lat.addColorStop(0.18, "rgba(0,0,0,0)");
			lat.addColorStop(0.82, "rgba(0,0,0,0)");
			lat.addColorStop(1, "rgba(0,0,0,0.16)");
			ctx.fillStyle = lat;
			ctx.fillRect(0, 0, 512, 256);

			if (speck) {
				ctx.globalAlpha = 0.26;
				for (let i = 0; i < 2400; i++) {
					const x = Math.random() * 512;
					const y = Math.random() * 256;
					const rr = Math.random() * 1.25;
					ctx.beginPath();
					ctx.arc(x, y, rr, 0, Math.PI * 2);
					ctx.fillStyle = Math.random() < 0.7 ? "rgba(0,0,0,1)" : "rgba(255,255,255,1)";
					ctx.fill();
				}
				ctx.globalAlpha = 1;
			}

			if (band) {
				for (let i = 0; i < 22; i++) {
					const y = (i / 22) * 256 + (Math.random() * 10 - 5);
					const h = 6 + Math.random() * 18;
					const a = 0.10 + Math.random() * 0.14;
					ctx.fillStyle = `rgba(255,255,255,${a})`;
					ctx.fillRect(0, y, 512, h);
				}
				ctx.globalAlpha = 0.10;
				for (let i = 0; i < 10; i++) {
					const y = Math.random() * 256;
					const h = 14 + Math.random() * 40;
					ctx.fillStyle = "rgba(0,0,0,1)";
					ctx.fillRect(0, y, 512, h);
				}
				ctx.globalAlpha = 1;
			}

			if (continents) {
				ctx.globalCompositeOperation = "overlay";
				ctx.globalAlpha = 0.50;
				for (let i = 0; i < 70; i++) {
					const x = Math.random() * 512;
					const y = Math.random() * 256;
					const rw = 18 + Math.random() * 120;
					const rh = 10 + Math.random() * 70;
					ctx.beginPath();
					ctx.ellipse(x, y, rw, rh, Math.random() * Math.PI, 0, Math.PI * 2);
					ctx.fillStyle = Math.random() < 0.6 ? "rgba(60,160,80,1)" : "rgba(120,110,60,1)";
					ctx.fill();
				}
				ctx.globalAlpha = 1;
				ctx.globalCompositeOperation = "source-over";
			}

			if (polarCaps) {
				const gN = ctx.createRadialGradient(256, 10, 0, 256, 10, 70);
				gN.addColorStop(0, "rgba(255,255,255,0.80)");
				gN.addColorStop(1, "rgba(255,255,255,0)");
				ctx.fillStyle = gN;
				ctx.fillRect(0, 0, 512, 256);

				const gS = ctx.createRadialGradient(256, 246, 0, 256, 246, 70);
				gS.addColorStop(0, "rgba(255,255,255,0.70)");
				gS.addColorStop(1, "rgba(255,255,255,0)");
				ctx.fillStyle = gS;
				ctx.fillRect(0, 0, 512, 256);
			}

			if (clouds) {
				ctx.globalAlpha = 0.14;
				ctx.fillStyle = "rgba(255,255,255,1)";
				for (let i = 0; i < 28; i++) {
					const y = Math.random() * 256;
					const h = 6 + Math.random() * 22;
					ctx.fillRect(0, y, 512, h);
				}
				ctx.globalAlpha = 1;
			}

			const tex = new THREE.CanvasTexture(c);
			tex.colorSpace = THREE.SRGBColorSpace;
			tex.wrapS = THREE.RepeatWrapping;
			tex.wrapT = THREE.RepeatWrapping;
			tex.anisotropy = 10;
			tex.needsUpdate = true;
			return tex;
		}

		// ---------- Scale ----------
		const BASE_SIZE_MULT = 2.55;
		const BASE_SUN_MULT = 2.15;
		const SIZE_MULT = BASE_SIZE_MULT * 2.0;
		const SUN_MULT = BASE_SUN_MULT * 2.0;

		const ELLIPSE_A = 1.22;
		const ELLIPSE_B = 0.78;

		const PLANETS = [
			{ name: "Mercury", r: 120, size: 3.0, speed: 1.55, tex: makePlanetTexture({ base1: "#d8d3cb", base2: "#4b433a", speck: true }) },
			{ name: "Venus",   r: 170, size: 4.3, speed: 1.25, tex: makePlanetTexture({ base1: "#ffe1b6", base2: "#7a4b23", clouds: true }) },
			{ name: "Earth",   r: 230, size: 4.6, speed: 1.00, tex: makePlanetTexture({ base1: "#2c86ff", base2: "#061a54", continents: true, clouds: true, polarCaps: true }) },
			{ name: "Mars",    r: 295, size: 3.8, speed: 0.82, tex: makePlanetTexture({ base1: "#f0a07a", base2: "#6a1e12", speck: true, polarCaps: true }) },
			{ name: "Jupiter", r: 385, size: 9.5, speed: 0.55, tex: makePlanetTexture({ base1: "#ffe7c7", base2: "#5b3b2a", band: true }) },
			{ name: "Saturn",  r: 475, size: 8.4, speed: 0.42, tex: makePlanetTexture({ base1: "#fff2c9", base2: "#7a5b2f", band: true }), ring: true },
			{ name: "Uranus",  r: 565, size: 6.2, speed: 0.30, tex: makePlanetTexture({ base1: "#c8fbff", base2: "#167b86", clouds: true }) },
			{ name: "Neptune", r: 660, size: 6.2, speed: 0.24, tex: makePlanetTexture({ base1: "#a4c0ff", base2: "#0a1a7a", clouds: true }) },
		].map(p => ({ ...p, size: p.size * SIZE_MULT }));

		const ORBIT_PADDING = 380;
		const OUTER_R = Math.max(...PLANETS.map(p => p.r)) * ELLIPSE_A + ORBIT_PADDING;

		function makeEllipseOrbit(radius) {
			const a = radius * ELLIPSE_A;
			const b = radius * ELLIPSE_B;
			const curve = new THREE.EllipseCurve(0, 0, a, b, 0, Math.PI * 2, false, 0);
			const pts2 = curve.getPoints(720);
			const pts3 = pts2.map(p => new THREE.Vector3(p.x, 0, p.y));
			pts3.push(pts3[0].clone());

			const geo = new THREE.BufferGeometry().setFromPoints(pts3);
			const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.18 });
			return new THREE.Line(geo, mat);
		}

		// ---------- Planet shader ----------
		const VERT = `
			varying vec2 vUv;
			varying vec3 vPosW;
			varying vec3 vNrmW;

			void main() {
				vUv = uv;
				vec4 worldPos = modelMatrix * vec4(position, 1.0);
				vPosW = worldPos.xyz;
				vNrmW = normalize(mat3(modelMatrix) * normal);
				gl_Position = projectionMatrix * viewMatrix * worldPos;
			}
		`;

		const FRAG = `
			precision highp float;

			uniform sampler2D uMap;
			uniform vec3 uSunPos;
			uniform vec3 uCamPos;

			uniform float uAmbient;
			uniform float uWrap;
			uniform float uSoftness;
			uniform float uSpecPow;
			uniform float uSpecAmp;
			uniform float uFresnel;

			varying vec2 vUv;
			varying vec3 vPosW;
			varying vec3 vNrmW;

			vec3 srgbToLinear(vec3 c) {
				return pow(c, vec3(2.2));
			}

			void main() {
				vec2 uv = vUv;

				vec4 texel = texture2D(uMap, uv);
				vec3 albedo = srgbToLinear(texel.rgb);

				vec3 N = normalize(vNrmW);
				vec3 L = normalize(uSunPos - vPosW);
				vec3 V = normalize(uCamPos - vPosW);

				float ndl = dot(N, L);
				float w = (ndl + uWrap) / (1.0 + uWrap);
				w = clamp(w, 0.0, 1.0);

				float lit = smoothstep(0.0, uSoftness, w);

				vec3 H = normalize(L + V);
				float ndh = max(dot(N, H), 0.0);
				float spec = pow(ndh, uSpecPow) * uSpecAmp * lit;

				float fres = pow(1.0 - max(dot(N, V), 0.0), 3.0) * uFresnel;

				float shade = mix(uAmbient, 1.0, lit);
				vec3 col = albedo * shade + spec + fres * 0.06;

				gl_FragColor = vec4(col, 1.0);
			}
		`;

		function makePlanetMaterial(mapTex, tuning = {}) {
			return new THREE.ShaderMaterial({
				uniforms: {
					uMap: { value: mapTex },
					uSunPos: { value: new THREE.Vector3(0, 0, 0) },
					uCamPos: { value: new THREE.Vector3() },

					uAmbient: { value: tuning.ambient ?? 0.16 },
					uWrap: { value: tuning.wrap ?? 0.18 },
					uSoftness: { value: tuning.softness ?? 0.10 },

					uSpecPow: { value: tuning.specPow ?? 32.0 },
					uSpecAmp: { value: tuning.specAmp ?? 0.06 },
					uFresnel: { value: tuning.fresnel ?? 0.35 },
				},
				vertexShader: VERT,
				fragmentShader: FRAG
			});
		}

		// ---------- Sun + glow ----------
		const sunGeo = new THREE.SphereGeometry(10.5 * SUN_MULT, 84, 84);
		const sunMat = new THREE.MeshBasicMaterial({ color: 0xfff1d6 });
		const sun = new THREE.Mesh(sunGeo, sunMat);
		sun.userData.name = "Sun";
		sun.renderOrder = 2;
		system.add(sun);

		function makeGlowTexture() {
			const c = document.createElement("canvas");
			c.width = 256; c.height = 256;
			const ctx = c.getContext("2d");
			const g = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
			g.addColorStop(0.00, "rgba(255,235,190,0.60)");
			g.addColorStop(0.16, "rgba(255,190,90,0.30)");
			g.addColorStop(0.42, "rgba(255,120,0,0.16)");
			g.addColorStop(1.00, "rgba(255,120,0,0)");
			ctx.fillStyle = g;
			ctx.fillRect(0, 0, 256, 256);

			const tex = new THREE.CanvasTexture(c);
			tex.colorSpace = THREE.SRGBColorSpace;
			tex.needsUpdate = true;
			return tex;
		}

		const glowTex = makeGlowTexture();

		function addGlow(size, opacity) {
			const geo = new THREE.PlaneGeometry(size, size);
			const mat = new THREE.MeshBasicMaterial({
				map: glowTex,
				transparent: true,
				opacity,
				depthWrite: false,

				// FIX: prevent geometry from "cutting holes" in the glow (the moving extra “shadow”)
				depthTest: false,

				blending: THREE.AdditiveBlending
			});
			const m = new THREE.Mesh(geo, mat);
			m.renderOrder = 1;
			m.frustumCulled = false;
			system.add(m);
			return m;
		}

		const glow1 = addGlow(240 * SUN_MULT, 0.55);
		const glow2 = addGlow(380 * SUN_MULT, 0.30);
		const glow3 = addGlow(620 * SUN_MULT, 0.16);

		// ---------- Planets on ellipse ----------
		const nodes = PLANETS.map((p, idx) => {
			orbitPlane.add(makeEllipseOrbit(p.r));

			const a = p.r * ELLIPSE_A;
			const b = p.r * ELLIPSE_B;

			const pivot = new THREE.Group();
			orbitPlane.add(pivot);

			const geo = new THREE.SphereGeometry(p.size, 64, 64);

			const tuning = (() => {
				switch (p.name) {
					case "Mercury": return { ambient: 0.13, wrap: 0.14, softness: 0.09, specPow: 26, specAmp: 0.05, fresnel: 0.28 };
					case "Venus":   return { ambient: 0.18, wrap: 0.22, softness: 0.12, specPow: 18, specAmp: 0.03, fresnel: 0.22 };
					case "Earth":   return { ambient: 0.14, wrap: 0.18, softness: 0.10, specPow: 40, specAmp: 0.08, fresnel: 0.40 };
					case "Mars":    return { ambient: 0.14, wrap: 0.16, softness: 0.10, specPow: 24, specAmp: 0.05, fresnel: 0.26 };
					case "Jupiter": return { ambient: 0.16, wrap: 0.22, softness: 0.12, specPow: 16, specAmp: 0.03, fresnel: 0.18 };
					case "Saturn":  return { ambient: 0.16, wrap: 0.22, softness: 0.12, specPow: 16, specAmp: 0.03, fresnel: 0.18 };
					case "Uranus":  return { ambient: 0.16, wrap: 0.20, softness: 0.11, specPow: 22, specAmp: 0.04, fresnel: 0.22 };
					case "Neptune": return { ambient: 0.16, wrap: 0.20, softness: 0.11, specPow: 22, specAmp: 0.04, fresnel: 0.22 };
				}
				return {};
			})();

			const mat = makePlanetMaterial(p.tex, tuning);
			const mesh = new THREE.Mesh(geo, mat);
			mesh.userData.name = p.name;
			pivot.add(mesh);

			if (p.ring) {
				const inner = p.size * 1.35;
				const outer = p.size * 2.05;
				const ringGeo = new THREE.RingGeometry(inner, outer, 220);
				const ringMat = new THREE.MeshBasicMaterial({
					color: 0xffffff,
					transparent: true,
					opacity: 0.22,
					side: THREE.DoubleSide,
					depthWrite: false
				});
				const ring = new THREE.Mesh(ringGeo, ringMat);
				ring.rotation.x = THREE.MathUtils.degToRad(72);
				ring.rotation.z = THREE.MathUtils.degToRad(-18);
				ring.userData.name = "Saturn (Rings)";
				pivot.add(ring);
			}

			const phase = idx * 0.65;
			const spin = 0.0022 + idx * 0.00012;

			return { pivot, mesh, mat, speed: p.speed, a, b, phase, spin };
		});

		// ---------- Camera ----------
		function applyCamera(zoom) {
			const dist = (OUTER_R * 1.58) / zoom;
			const height = (OUTER_R * 0.10) / zoom;
			const xoff = (OUTER_R * 0.34) / zoom;

			camera.position.set(xoff, height, dist);
			camera.lookAt(0, 0, 0);
			camera.updateProjectionMatrix();
		}

		// ---------- Controls ----------
		const rSpeed = document.getElementById("speed");
		const rTilt = document.getElementById("tilt");
		const rZoom = document.getElementById("zoom");
		const speedVal = document.getElementById("speedVal");
		const tiltVal = document.getElementById("tiltVal");
		const zoomVal = document.getElementById("zoomVal");

		function applyVars() {
			const speed = Number(rSpeed.value);
			const tiltDeg = Number(rTilt.value);
			const zoom = Number(rZoom.value);

			speedVal.textContent = speed.toFixed(2);
			tiltVal.textContent = tiltDeg + "°";
			zoomVal.textContent = zoom.toFixed(2);

			orbitPlane.rotation.x = THREE.MathUtils.degToRad(tiltDeg);
			applyCamera(zoom);
		}
		[rSpeed, rTilt, rZoom].forEach(el => el.addEventListener("input", applyVars));
		applyVars();

		// ---------- Hover ----------
		const tip = document.getElementById("tip");
		const raycaster = new THREE.Raycaster();
		const mouse = new THREE.Vector2();

		function setTip(on, x, y, text) {
			if (!on) {
				tip.classList.remove("on");
				tip.textContent = "";
				canvas.style.cursor = "default";
				return;
			}
			tip.textContent = text;
			tip.style.left = x + "px";
			tip.style.top = y + "px";
			tip.classList.add("on");
			canvas.style.cursor = "pointer";
		}

		function onMove(ev) {
			const rect = canvas.getBoundingClientRect();
			const x = ev.clientX - rect.left;
			const y = ev.clientY - rect.top;

			mouse.x = (x / rect.width) * 2 - 1;
			mouse.y = -(y / rect.height) * 2 + 1;

			raycaster.setFromCamera(mouse, camera);

			const pickables = [sun, ...nodes.map(n => n.mesh)];
			const hits = raycaster.intersectObjects(pickables, true);

			if (hits.length) {
				const obj = hits[0].object;
				const name = obj.userData?.name || "";
				if (name) {
					setTip(true, ev.clientX, ev.clientY, name);
					return;
				}
			}
			setTip(false);
		}

		canvas.addEventListener("mousemove", onMove, { passive: true });
		canvas.addEventListener("mouseleave", () => setTip(false), { passive: true });

		// ---------- Resize ----------
		function onResize() {
			renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
			renderer.setSize(innerWidth, innerHeight, false);
			camera.aspect = innerWidth / innerHeight;
			camera.updateProjectionMatrix();
			resizeStars();
			applyVars();
		}
		window.addEventListener("resize", onResize, { passive: true });
		resizeStars();

		// ---------- Loop ----------
		const clock = new THREE.Clock();
		const SUN_POS = new THREE.Vector3(0, 0, 0);

		function tick() {
			const t = clock.getElapsedTime();
			const speed = Number(rSpeed.value);

			glow1.lookAt(camera.position);
			glow2.lookAt(camera.position);
			glow3.lookAt(camera.position);

			sun.scale.setScalar(1 + Math.sin(t * 1.5) * 0.01);

			for (const n of nodes) {
				const ang = (t * 0.38 * n.speed * speed) + n.phase;
				n.pivot.position.set(
					n.a * Math.cos(ang),
					0,
					n.b * Math.sin(ang)
				);

				n.mat.uniforms.uSunPos.value.copy(SUN_POS);
				n.mat.uniforms.uCamPos.value.copy(camera.position);

				n.mesh.rotation.y += n.spin * speed;
			}

			renderer.render(scene, camera);
			requestAnimationFrame(tick);
		}
		tick();
	</script>
</body>

</html>
